/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tpcw.config;

import ignite.datasource.DataSourceFactory;

import java.sql.*;
import java.util.*;

import javax.sql.DataSource;

import org.apache.ignite.cache.*;
import org.apache.ignite.cache.store.jdbc.*;
import org.apache.ignite.configuration.*;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

/**
 * CacheConfig definition.
 *
 * Code generated by Apache Ignite Schema Import utility: 10/09/2016.
 */
public class CacheConfig {
	static DriverManagerDataSource dataSource = null;

	/**
	 * Create JDBC type for address.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Configured JDBC type.
	 */
	private static JdbcType jdbcTypeAddress(String cacheName) {
		JdbcType jdbcType = new JdbcType();

		jdbcType.setCacheName(cacheName);
		jdbcType.setDatabaseSchema("tpcw");
		jdbcType.setDatabaseTable("address");
		jdbcType.setKeyType("tpcw.bean.AddressKey");
		jdbcType.setValueType("tpcw.bean.Address");

		// Key fields for address.
		Collection<JdbcTypeField> keys = new ArrayList<>();
		keys.add(new JdbcTypeField(Types.INTEGER, "ADDR_ID", int.class,
				"addrId"));
		jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

		// Value fields for address.
		Collection<JdbcTypeField> vals = new ArrayList<>();
		vals.add(new JdbcTypeField(Types.INTEGER, "ADDR_ID", int.class,
				"addrId"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "ADDR_STREET1", String.class,
				"addrStreet1"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "ADDR_STREET2", String.class,
				"addrStreet2"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "ADDR_CITY", String.class,
				"addrCity"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "ADDR_STATE", String.class,
				"addrState"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "ADDR_ZIP", String.class,
				"addrZip"));
		vals.add(new JdbcTypeField(Types.INTEGER, "ADDR_CO_ID", Integer.class,
				"addrCoId"));
		jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

		return jdbcType;
	}

	/**
	 * Create SQL Query descriptor for address.
	 *
	 * @return Configured query entity.
	 */
	private static QueryEntity queryEntityAddress() {
		QueryEntity qryEntity = new QueryEntity();

		qryEntity.setKeyType("tpcw.bean.AddressKey");
		qryEntity.setValueType("tpcw.bean.Address");

		// Query fields for address.
		LinkedHashMap<String, String> fields = new LinkedHashMap<>();

		fields.put("addrId", "java.lang.Integer");
		fields.put("addrStreet1", "java.lang.String");
		fields.put("addrStreet2", "java.lang.String");
		fields.put("addrCity", "java.lang.String");
		fields.put("addrState", "java.lang.String");
		fields.put("addrZip", "java.lang.String");
		fields.put("addrCoId", "java.lang.Integer");

		qryEntity.setFields(fields);

		// Aliases for fields.
		Map<String, String> aliases = new HashMap<>();

		aliases.put("addrId", "ADDR_ID");
		aliases.put("addrStreet1", "ADDR_STREET1");
		aliases.put("addrStreet2", "ADDR_STREET2");
		aliases.put("addrCity", "ADDR_CITY");
		aliases.put("addrState", "ADDR_STATE");
		aliases.put("addrZip", "ADDR_ZIP");
		aliases.put("addrCoId", "ADDR_CO_ID");

		qryEntity.setAliases(aliases);

		// Indexes for address.
		Collection<QueryIndex> idxs = new ArrayList<>();

		idxs.add(new QueryIndex("addrId", true, "PRIMARY"));

		qryEntity.setIndexes(idxs);

		return qryEntity;
	}

	/**
	 * Create JDBC type for author.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Configured JDBC type.
	 */
	private static JdbcType jdbcTypeAuthor(String cacheName) {
		JdbcType jdbcType = new JdbcType();

		jdbcType.setCacheName(cacheName);
		jdbcType.setDatabaseSchema("tpcw");
		jdbcType.setDatabaseTable("author");
		jdbcType.setKeyType("tpcw.bean.AuthorKey");
		jdbcType.setValueType("tpcw.bean.Author");

		// Key fields for author.
		Collection<JdbcTypeField> keys = new ArrayList<>();
		keys.add(new JdbcTypeField(Types.INTEGER, "A_ID", int.class, "aId"));
		jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

		// Value fields for author.
		Collection<JdbcTypeField> vals = new ArrayList<>();
		vals.add(new JdbcTypeField(Types.INTEGER, "A_ID", int.class, "aId"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "A_FNAME", String.class,
				"aFname"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "A_LNAME", String.class,
				"aLname"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "A_MNAME", String.class,
				"aMname"));
		vals.add(new JdbcTypeField(Types.DATE, "A_DOB", java.sql.Date.class,
				"aDob"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "A_BIO", String.class, "aBio"));
		jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

		return jdbcType;
	}

	/**
	 * Create SQL Query descriptor for author.
	 *
	 * @return Configured query entity.
	 */
	private static QueryEntity queryEntityAuthor() {
		QueryEntity qryEntity = new QueryEntity();

		qryEntity.setKeyType("tpcw.bean.AuthorKey");
		qryEntity.setValueType("tpcw.bean.Author");

		// Query fields for author.
		LinkedHashMap<String, String> fields = new LinkedHashMap<>();

		fields.put("aId", "java.lang.Integer");
		fields.put("aFname", "java.lang.String");
		fields.put("aLname", "java.lang.String");
		fields.put("aMname", "java.lang.String");
		fields.put("aDob", "java.sql.Date");
		fields.put("aBio", "java.lang.String");

		qryEntity.setFields(fields);

		// Aliases for fields.
		Map<String, String> aliases = new HashMap<>();

		aliases.put("aId", "A_ID");
		aliases.put("aFname", "A_FNAME");
		aliases.put("aLname", "A_LNAME");
		aliases.put("aMname", "A_MNAME");
		aliases.put("aDob", "A_DOB");
		aliases.put("aBio", "A_BIO");

		qryEntity.setAliases(aliases);

		// Indexes for author.
		Collection<QueryIndex> idxs = new ArrayList<>();

		idxs.add(new QueryIndex("aId", true, "PRIMARY"));

		qryEntity.setIndexes(idxs);

		return qryEntity;
	}

	/**
	 * Create JDBC type for cc_xacts.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Configured JDBC type.
	 */
	private static JdbcType jdbcTypeCcXacts(String cacheName) {
		JdbcType jdbcType = new JdbcType();

		jdbcType.setCacheName(cacheName);
		jdbcType.setDatabaseSchema("tpcw");
		jdbcType.setDatabaseTable("cc_xacts");
		jdbcType.setKeyType("tpcw.bean.CcXactsKey");
		jdbcType.setValueType("tpcw.bean.CcXacts");

		// Key fields for cc_xacts.
		Collection<JdbcTypeField> keys = new ArrayList<>();
		keys.add(new JdbcTypeField(Types.INTEGER, "CX_O_ID", int.class, "cxOId"));
		jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

		// Value fields for cc_xacts.
		Collection<JdbcTypeField> vals = new ArrayList<>();
		vals.add(new JdbcTypeField(Types.INTEGER, "CX_O_ID", int.class, "cxOId"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "CX_TYPE", String.class,
				"cxType"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "CX_NUM", String.class,
				"cxNum"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "CX_NAME", String.class,
				"cxName"));
		vals.add(new JdbcTypeField(Types.DATE, "CX_EXPIRE",
				java.sql.Date.class, "cxExpire"));
		vals.add(new JdbcTypeField(Types.CHAR, "CX_AUTH_ID", String.class,
				"cxAuthId"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "CX_XACT_AMT", Double.class,
				"cxXactAmt"));
		vals.add(new JdbcTypeField(Types.DATE, "CX_XACT_DATE",
				java.sql.Date.class, "cxXactDate"));
		vals.add(new JdbcTypeField(Types.INTEGER, "CX_CO_ID", Integer.class,
				"cxCoId"));
		jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

		return jdbcType;
	}

	/**
	 * Create SQL Query descriptor for cc_xacts.
	 *
	 * @return Configured query entity.
	 */
	private static QueryEntity queryEntityCcXacts() {
		QueryEntity qryEntity = new QueryEntity();

		qryEntity.setKeyType("tpcw.bean.CcXactsKey");
		qryEntity.setValueType("tpcw.bean.CcXacts");

		// Query fields for cc_xacts.
		LinkedHashMap<String, String> fields = new LinkedHashMap<>();

		fields.put("cxOId", "java.lang.Integer");
		fields.put("cxType", "java.lang.String");
		fields.put("cxNum", "java.lang.String");
		fields.put("cxName", "java.lang.String");
		fields.put("cxExpire", "java.sql.Date");
		fields.put("cxAuthId", "java.lang.String");
		fields.put("cxXactAmt", "java.lang.Double");
		fields.put("cxXactDate", "java.sql.Date");
		fields.put("cxCoId", "java.lang.Integer");

		qryEntity.setFields(fields);

		// Aliases for fields.
		Map<String, String> aliases = new HashMap<>();

		aliases.put("cxOId", "CX_O_ID");
		aliases.put("cxType", "CX_TYPE");
		aliases.put("cxNum", "CX_NUM");
		aliases.put("cxName", "CX_NAME");
		aliases.put("cxExpire", "CX_EXPIRE");
		aliases.put("cxAuthId", "CX_AUTH_ID");
		aliases.put("cxXactAmt", "CX_XACT_AMT");
		aliases.put("cxXactDate", "CX_XACT_DATE");
		aliases.put("cxCoId", "CX_CO_ID");

		qryEntity.setAliases(aliases);

		// Indexes for cc_xacts.
		Collection<QueryIndex> idxs = new ArrayList<>();

		idxs.add(new QueryIndex("cxOId", true, "PRIMARY"));

		qryEntity.setIndexes(idxs);

		return qryEntity;
	}

	/**
	 * Create JDBC type for country.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Configured JDBC type.
	 */
	private static JdbcType jdbcTypeCountry(String cacheName) {
		JdbcType jdbcType = new JdbcType();

		jdbcType.setCacheName(cacheName);
		jdbcType.setDatabaseSchema("tpcw");
		jdbcType.setDatabaseTable("country");
		jdbcType.setKeyType("tpcw.bean.CountryKey");
		jdbcType.setValueType("tpcw.bean.Country");

		// Key fields for country.
		Collection<JdbcTypeField> keys = new ArrayList<>();
		keys.add(new JdbcTypeField(Types.INTEGER, "CO_ID", int.class, "coId"));
		jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

		// Value fields for country.
		Collection<JdbcTypeField> vals = new ArrayList<>();
		vals.add(new JdbcTypeField(Types.INTEGER, "CO_ID", int.class, "coId"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "CO_NAME", String.class,
				"coName"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "CO_EXCHANGE", Double.class,
				"coExchange"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "CO_CURRENCY", String.class,
				"coCurrency"));
		jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

		return jdbcType;
	}

	/**
	 * Create SQL Query descriptor for country.
	 *
	 * @return Configured query entity.
	 */
	private static QueryEntity queryEntityCountry() {
		QueryEntity qryEntity = new QueryEntity();

		qryEntity.setKeyType("tpcw.bean.CountryKey");
		qryEntity.setValueType("tpcw.bean.Country");

		// Query fields for country.
		LinkedHashMap<String, String> fields = new LinkedHashMap<>();

		fields.put("coId", "java.lang.Integer");
		fields.put("coName", "java.lang.String");
		fields.put("coExchange", "java.lang.Double");
		fields.put("coCurrency", "java.lang.String");

		qryEntity.setFields(fields);

		// Aliases for fields.
		Map<String, String> aliases = new HashMap<>();

		aliases.put("coId", "CO_ID");
		aliases.put("coName", "CO_NAME");
		aliases.put("coExchange", "CO_EXCHANGE");
		aliases.put("coCurrency", "CO_CURRENCY");

		qryEntity.setAliases(aliases);

		// Indexes for country.
		Collection<QueryIndex> idxs = new ArrayList<>();

		idxs.add(new QueryIndex("coId", true, "PRIMARY"));

		qryEntity.setIndexes(idxs);

		return qryEntity;
	}

	/**
	 * Create JDBC type for customer.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Configured JDBC type.
	 */
	private static JdbcType jdbcTypeCustomer(String cacheName) {
		JdbcType jdbcType = new JdbcType();

		jdbcType.setCacheName(cacheName);
		jdbcType.setDatabaseSchema("tpcw");
		jdbcType.setDatabaseTable("customer");
		jdbcType.setKeyType("tpcw.bean.CustomerKey");
		jdbcType.setValueType("tpcw.bean.Customer");

		// Key fields for customer.
		Collection<JdbcTypeField> keys = new ArrayList<>();
		keys.add(new JdbcTypeField(Types.INTEGER, "C_ID", int.class, "cId"));
		jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

		// Value fields for customer.
		Collection<JdbcTypeField> vals = new ArrayList<>();
		vals.add(new JdbcTypeField(Types.INTEGER, "C_ID", int.class, "cId"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "C_UNAME", String.class,
				"cUname"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "C_PASSWD", String.class,
				"cPasswd"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "C_FNAME", String.class,
				"cFname"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "C_LNAME", String.class,
				"cLname"));
		vals.add(new JdbcTypeField(Types.INTEGER, "C_ADDR_ID", Integer.class,
				"cAddrId"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "C_PHONE", String.class,
				"cPhone"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "C_EMAIL", String.class,
				"cEmail"));
		vals.add(new JdbcTypeField(Types.DATE, "C_SINCE", java.sql.Date.class,
				"cSince"));
		vals.add(new JdbcTypeField(Types.DATE, "C_LAST_LOGIN",
				java.sql.Date.class, "cLastLogin"));
		vals.add(new JdbcTypeField(Types.TIMESTAMP, "C_LOGIN",
				java.sql.Timestamp.class, "cLogin"));
		vals.add(new JdbcTypeField(Types.TIMESTAMP, "C_EXPIRATION",
				java.sql.Timestamp.class, "cExpiration"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "C_DISCOUNT", Double.class,
				"cDiscount"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "C_BALANCE", Double.class,
				"cBalance"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "C_YTD_PMT", Double.class,
				"cYtdPmt"));
		vals.add(new JdbcTypeField(Types.DATE, "C_BIRTHDATE",
				java.sql.Date.class, "cBirthdate"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "C_DATA", String.class,
				"cData"));
		jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

		return jdbcType;
	}

	/**
	 * Create SQL Query descriptor for customer.
	 *
	 * @return Configured query entity.
	 */
	private static QueryEntity queryEntityCustomer() {
		QueryEntity qryEntity = new QueryEntity();

		qryEntity.setKeyType("tpcw.bean.CustomerKey");
		qryEntity.setValueType("tpcw.bean.Customer");

		// Query fields for customer.
		LinkedHashMap<String, String> fields = new LinkedHashMap<>();

		fields.put("cId", "java.lang.Integer");
		fields.put("cUname", "java.lang.String");
		fields.put("cPasswd", "java.lang.String");
		fields.put("cFname", "java.lang.String");
		fields.put("cLname", "java.lang.String");
		fields.put("cAddrId", "java.lang.Integer");
		fields.put("cPhone", "java.lang.String");
		fields.put("cEmail", "java.lang.String");
		fields.put("cSince", "java.sql.Date");
		fields.put("cLastLogin", "java.sql.Date");
		fields.put("cLogin", "java.sql.Timestamp");
		fields.put("cExpiration", "java.sql.Timestamp");
		fields.put("cDiscount", "java.lang.Double");
		fields.put("cBalance", "java.lang.Double");
		fields.put("cYtdPmt", "java.lang.Double");
		fields.put("cBirthdate", "java.sql.Date");
		fields.put("cData", "java.lang.String");

		qryEntity.setFields(fields);

		// Aliases for fields.
		Map<String, String> aliases = new HashMap<>();

		aliases.put("cId", "C_ID");
		aliases.put("cUname", "C_UNAME");
		aliases.put("cPasswd", "C_PASSWD");
		aliases.put("cFname", "C_FNAME");
		aliases.put("cLname", "C_LNAME");
		aliases.put("cAddrId", "C_ADDR_ID");
		aliases.put("cPhone", "C_PHONE");
		aliases.put("cEmail", "C_EMAIL");
		aliases.put("cSince", "C_SINCE");
		aliases.put("cLastLogin", "C_LAST_LOGIN");
		aliases.put("cLogin", "C_LOGIN");
		aliases.put("cExpiration", "C_EXPIRATION");
		aliases.put("cDiscount", "C_DISCOUNT");
		aliases.put("cBalance", "C_BALANCE");
		aliases.put("cYtdPmt", "C_YTD_PMT");
		aliases.put("cBirthdate", "C_BIRTHDATE");
		aliases.put("cData", "C_DATA");

		qryEntity.setAliases(aliases);

		// Indexes for customer.
		Collection<QueryIndex> idxs = new ArrayList<>();

		idxs.add(new QueryIndex("cId", true, "PRIMARY"));

		qryEntity.setIndexes(idxs);

		return qryEntity;
	}

	/**
	 * Create JDBC type for item.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Configured JDBC type.
	 */
	private static JdbcType jdbcTypeItem(String cacheName) {
		JdbcType jdbcType = new JdbcType();

		jdbcType.setCacheName(cacheName);
		jdbcType.setDatabaseSchema("tpcw");
		jdbcType.setDatabaseTable("item");
		jdbcType.setKeyType("tpcw.bean.ItemKey");
		jdbcType.setValueType("tpcw.bean.Item");

		// Key fields for item.
		Collection<JdbcTypeField> keys = new ArrayList<>();
		keys.add(new JdbcTypeField(Types.INTEGER, "I_ID", int.class, "iId"));
		jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

		// Value fields for item.
		Collection<JdbcTypeField> vals = new ArrayList<>();
		vals.add(new JdbcTypeField(Types.INTEGER, "I_ID", int.class, "iId"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "I_TITLE", String.class,
				"iTitle"));
		vals.add(new JdbcTypeField(Types.INTEGER, "I_A_ID", Integer.class,
				"iAId"));
		vals.add(new JdbcTypeField(Types.DATE, "I_PUB_DATE",
				java.sql.Date.class, "iPubDate"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "I_PUBLISHER", String.class,
				"iPublisher"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "I_SUBJECT", String.class,
				"iSubject"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "I_DESC", String.class,
				"iDesc"));
		vals.add(new JdbcTypeField(Types.INTEGER, "I_RELATED1", Integer.class,
				"iRelated1"));
		vals.add(new JdbcTypeField(Types.INTEGER, "I_RELATED2", Integer.class,
				"iRelated2"));
		vals.add(new JdbcTypeField(Types.INTEGER, "I_RELATED3", Integer.class,
				"iRelated3"));
		vals.add(new JdbcTypeField(Types.INTEGER, "I_RELATED4", Integer.class,
				"iRelated4"));
		vals.add(new JdbcTypeField(Types.INTEGER, "I_RELATED5", Integer.class,
				"iRelated5"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "I_THUMBNAIL", String.class,
				"iThumbnail"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "I_IMAGE", String.class,
				"iImage"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "I_SRP", Double.class, "iSrp"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "I_COST", Double.class,
				"iCost"));
		vals.add(new JdbcTypeField(Types.DATE, "I_AVAIL", java.sql.Date.class,
				"iAvail"));
		vals.add(new JdbcTypeField(Types.INTEGER, "I_STOCK", Integer.class,
				"iStock"));
		vals.add(new JdbcTypeField(Types.CHAR, "I_ISBN", String.class, "iIsbn"));
		vals.add(new JdbcTypeField(Types.INTEGER, "I_PAGE", Integer.class,
				"iPage"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "I_BACKING", String.class,
				"iBacking"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "I_DIMENSIONS", String.class,
				"iDimensions"));
		jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

		return jdbcType;
	}

	/**
	 * Create SQL Query descriptor for item.
	 *
	 * @return Configured query entity.
	 */
	private static QueryEntity queryEntityItem() {
		QueryEntity qryEntity = new QueryEntity();

		qryEntity.setKeyType("tpcw.bean.ItemKey");
		qryEntity.setValueType("tpcw.bean.Item");

		// Query fields for item.
		LinkedHashMap<String, String> fields = new LinkedHashMap<>();

		fields.put("iId", "java.lang.Integer");
		fields.put("iTitle", "java.lang.String");
		fields.put("iAId", "java.lang.Integer");
		fields.put("iPubDate", "java.sql.Date");
		fields.put("iPublisher", "java.lang.String");
		fields.put("iSubject", "java.lang.String");
		fields.put("iDesc", "java.lang.String");
		fields.put("iRelated1", "java.lang.Integer");
		fields.put("iRelated2", "java.lang.Integer");
		fields.put("iRelated3", "java.lang.Integer");
		fields.put("iRelated4", "java.lang.Integer");
		fields.put("iRelated5", "java.lang.Integer");
		fields.put("iThumbnail", "java.lang.String");
		fields.put("iImage", "java.lang.String");
		fields.put("iSrp", "java.lang.Double");
		fields.put("iCost", "java.lang.Double");
		fields.put("iAvail", "java.sql.Date");
		fields.put("iStock", "java.lang.Integer");
		fields.put("iIsbn", "java.lang.String");
		fields.put("iPage", "java.lang.Integer");
		fields.put("iBacking", "java.lang.String");
		fields.put("iDimensions", "java.lang.String");

		qryEntity.setFields(fields);

		// Aliases for fields.
		Map<String, String> aliases = new HashMap<>();

		aliases.put("iId", "I_ID");
		aliases.put("iTitle", "I_TITLE");
		aliases.put("iAId", "I_A_ID");
		aliases.put("iPubDate", "I_PUB_DATE");
		aliases.put("iPublisher", "I_PUBLISHER");
		aliases.put("iSubject", "I_SUBJECT");
		aliases.put("iDesc", "I_DESC");
		aliases.put("iRelated1", "I_RELATED1");
		aliases.put("iRelated2", "I_RELATED2");
		aliases.put("iRelated3", "I_RELATED3");
		aliases.put("iRelated4", "I_RELATED4");
		aliases.put("iRelated5", "I_RELATED5");
		aliases.put("iThumbnail", "I_THUMBNAIL");
		aliases.put("iImage", "I_IMAGE");
		aliases.put("iSrp", "I_SRP");
		aliases.put("iCost", "I_COST");
		aliases.put("iAvail", "I_AVAIL");
		aliases.put("iStock", "I_STOCK");
		aliases.put("iIsbn", "I_ISBN");
		aliases.put("iPage", "I_PAGE");
		aliases.put("iBacking", "I_BACKING");
		aliases.put("iDimensions", "I_DIMENSIONS");

		qryEntity.setAliases(aliases);

		// Indexes for item.
		Collection<QueryIndex> idxs = new ArrayList<>();

		idxs.add(new QueryIndex("iId", true, "PRIMARY"));

		qryEntity.setIndexes(idxs);

		return qryEntity;
	}

	/**
	 * Create JDBC type for order_line.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Configured JDBC type.
	 */
	private static JdbcType jdbcTypeOrderLine(String cacheName) {
		JdbcType jdbcType = new JdbcType();

		jdbcType.setCacheName(cacheName);
		jdbcType.setDatabaseSchema("tpcw");
		jdbcType.setDatabaseTable("order_line");
		jdbcType.setKeyType("tpcw.bean.OrderLineKey");
		jdbcType.setValueType("tpcw.bean.OrderLine");

		// Key fields for order_line.
		Collection<JdbcTypeField> keys = new ArrayList<>();
		keys.add(new JdbcTypeField(Types.INTEGER, "OL_ID", int.class, "olId"));
		keys.add(new JdbcTypeField(Types.INTEGER, "OL_O_ID", int.class, "olOId"));
		jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

		// Value fields for order_line.
		Collection<JdbcTypeField> vals = new ArrayList<>();
		vals.add(new JdbcTypeField(Types.INTEGER, "OL_ID", int.class, "olId"));
		vals.add(new JdbcTypeField(Types.INTEGER, "OL_O_ID", int.class, "olOId"));
		vals.add(new JdbcTypeField(Types.INTEGER, "OL_I_ID", Integer.class,
				"olIId"));
		vals.add(new JdbcTypeField(Types.INTEGER, "OL_QTY", Integer.class,
				"olQty"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "OL_DISCOUNT", Double.class,
				"olDiscount"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "OL_COMMENTS", String.class,
				"olComments"));
		jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

		return jdbcType;
	}

	/**
	 * Create SQL Query descriptor for order_line.
	 *
	 * @return Configured query entity.
	 */
	private static QueryEntity queryEntityOrderLine() {
		QueryEntity qryEntity = new QueryEntity();

		qryEntity.setKeyType("tpcw.bean.OrderLineKey");
		qryEntity.setValueType("tpcw.bean.OrderLine");

		// Query fields for order_line.
		LinkedHashMap<String, String> fields = new LinkedHashMap<>();

		fields.put("olId", "java.lang.Integer");
		fields.put("olOId", "java.lang.Integer");
		fields.put("olIId", "java.lang.Integer");
		fields.put("olQty", "java.lang.Integer");
		fields.put("olDiscount", "java.lang.Double");
		fields.put("olComments", "java.lang.String");

		qryEntity.setFields(fields);

		// Aliases for fields.
		Map<String, String> aliases = new HashMap<>();

		aliases.put("olId", "OL_ID");
		aliases.put("olOId", "OL_O_ID");
		aliases.put("olIId", "OL_I_ID");
		aliases.put("olQty", "OL_QTY");
		aliases.put("olDiscount", "OL_DISCOUNT");
		aliases.put("olComments", "OL_COMMENTS");

		qryEntity.setAliases(aliases);

		// Indexes for order_line.
		Collection<QueryIndex> idxs = new ArrayList<>();

		QueryIndex idx = new QueryIndex();

		idx.setName("PRIMARY");

		LinkedHashMap<String, Boolean> idxFlds = new LinkedHashMap<>();

		idxFlds.put("olId", true);
		idxFlds.put("olOId", true);

		idx.setFields(idxFlds);

		idxs.add(idx);

		qryEntity.setIndexes(idxs);

		return qryEntity;
	}

	/**
	 * Create JDBC type for orders.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Configured JDBC type.
	 */
	private static JdbcType jdbcTypeOrders(String cacheName) {
		JdbcType jdbcType = new JdbcType();

		jdbcType.setCacheName(cacheName);
		jdbcType.setDatabaseSchema("tpcw");
		jdbcType.setDatabaseTable("orders");
		jdbcType.setKeyType("tpcw.bean.OrdersKey");
		jdbcType.setValueType("tpcw.bean.Orders");

		// Key fields for orders.
		Collection<JdbcTypeField> keys = new ArrayList<>();
		keys.add(new JdbcTypeField(Types.INTEGER, "O_ID", int.class, "oId"));
		jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

		// Value fields for orders.
		Collection<JdbcTypeField> vals = new ArrayList<>();
		vals.add(new JdbcTypeField(Types.INTEGER, "O_ID", int.class, "oId"));
		vals.add(new JdbcTypeField(Types.INTEGER, "O_C_ID", Integer.class,
				"oCId"));
		vals.add(new JdbcTypeField(Types.DATE, "O_DATE", java.sql.Date.class,
				"oDate"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "O_SUB_TOTAL", Double.class,
				"oSubTotal"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "O_TAX", Double.class, "oTax"));
		vals.add(new JdbcTypeField(Types.DOUBLE, "O_TOTAL", Double.class,
				"oTotal"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "O_SHIP_TYPE", String.class,
				"oShipType"));
		vals.add(new JdbcTypeField(Types.DATE, "O_SHIP_DATE",
				java.sql.Date.class, "oShipDate"));
		vals.add(new JdbcTypeField(Types.INTEGER, "O_BILL_ADDR_ID",
				Integer.class, "oBillAddrId"));
		vals.add(new JdbcTypeField(Types.INTEGER, "O_SHIP_ADDR_ID",
				Integer.class, "oShipAddrId"));
		vals.add(new JdbcTypeField(Types.VARCHAR, "O_STATUS", String.class,
				"oStatus"));
		jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

		return jdbcType;
	}

	/**
	 * Create SQL Query descriptor for orders.
	 *
	 * @return Configured query entity.
	 */
	private static QueryEntity queryEntityOrders() {
		QueryEntity qryEntity = new QueryEntity();

		qryEntity.setKeyType("tpcw.bean.OrdersKey");
		qryEntity.setValueType("tpcw.bean.Orders");

		// Query fields for orders.
		LinkedHashMap<String, String> fields = new LinkedHashMap<>();

		fields.put("oId", "java.lang.Integer");
		fields.put("oCId", "java.lang.Integer");
		fields.put("oDate", "java.sql.Date");
		fields.put("oSubTotal", "java.lang.Double");
		fields.put("oTax", "java.lang.Double");
		fields.put("oTotal", "java.lang.Double");
		fields.put("oShipType", "java.lang.String");
		fields.put("oShipDate", "java.sql.Date");
		fields.put("oBillAddrId", "java.lang.Integer");
		fields.put("oShipAddrId", "java.lang.Integer");
		fields.put("oStatus", "java.lang.String");

		qryEntity.setFields(fields);

		// Aliases for fields.
		Map<String, String> aliases = new HashMap<>();

		aliases.put("oId", "O_ID");
		aliases.put("oCId", "O_C_ID");
		aliases.put("oDate", "O_DATE");
		aliases.put("oSubTotal", "O_SUB_TOTAL");
		aliases.put("oTax", "O_TAX");
		aliases.put("oTotal", "O_TOTAL");
		aliases.put("oShipType", "O_SHIP_TYPE");
		aliases.put("oShipDate", "O_SHIP_DATE");
		aliases.put("oBillAddrId", "O_BILL_ADDR_ID");
		aliases.put("oShipAddrId", "O_SHIP_ADDR_ID");
		aliases.put("oStatus", "O_STATUS");

		qryEntity.setAliases(aliases);

		// Indexes for orders.
		Collection<QueryIndex> idxs = new ArrayList<>();

		idxs.add(new QueryIndex("oId", true, "PRIMARY"));

		qryEntity.setIndexes(idxs);

		return qryEntity;
	}

	/**
	 * Create JDBC type for shopping_cart.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Configured JDBC type.
	 */
	private static JdbcType jdbcTypeShoppingCart(String cacheName) {
		JdbcType jdbcType = new JdbcType();

		jdbcType.setCacheName(cacheName);
		jdbcType.setDatabaseSchema("tpcw");
		jdbcType.setDatabaseTable("shopping_cart");
		jdbcType.setKeyType("tpcw.bean.ShoppingCartKey");
		jdbcType.setValueType("tpcw.bean.ShoppingCart");

		// Key fields for shopping_cart.
		Collection<JdbcTypeField> keys = new ArrayList<>();
		keys.add(new JdbcTypeField(Types.INTEGER, "SC_ID", int.class, "scId"));
		jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

		// Value fields for shopping_cart.
		Collection<JdbcTypeField> vals = new ArrayList<>();
		vals.add(new JdbcTypeField(Types.INTEGER, "SC_ID", int.class, "scId"));
		vals.add(new JdbcTypeField(Types.TIMESTAMP, "SC_TIME",
				java.sql.Timestamp.class, "scTime"));
		jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

		return jdbcType;
	}

	/**
	 * Create SQL Query descriptor for shopping_cart.
	 *
	 * @return Configured query entity.
	 */
	private static QueryEntity queryEntityShoppingCart() {
		QueryEntity qryEntity = new QueryEntity();

		qryEntity.setKeyType("tpcw.bean.ShoppingCartKey");
		qryEntity.setValueType("tpcw.bean.ShoppingCart");

		// Query fields for shopping_cart.
		LinkedHashMap<String, String> fields = new LinkedHashMap<>();

		fields.put("scId", "java.lang.Integer");
		fields.put("scTime", "java.sql.Timestamp");

		qryEntity.setFields(fields);

		// Aliases for fields.
		Map<String, String> aliases = new HashMap<>();

		aliases.put("scId", "SC_ID");
		aliases.put("scTime", "SC_TIME");

		qryEntity.setAliases(aliases);

		// Indexes for shopping_cart.
		Collection<QueryIndex> idxs = new ArrayList<>();

		idxs.add(new QueryIndex("scId", true, "PRIMARY"));

		qryEntity.setIndexes(idxs);

		return qryEntity;
	}

	/**
	 * Create JDBC type for shopping_cart_line.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Configured JDBC type.
	 */
	private static JdbcType jdbcTypeShoppingCartLine(String cacheName) {
		JdbcType jdbcType = new JdbcType();

		jdbcType.setCacheName(cacheName);
		jdbcType.setDatabaseSchema("tpcw");
		jdbcType.setDatabaseTable("shopping_cart_line");
		jdbcType.setKeyType("tpcw.bean.ShoppingCartLineKey");
		jdbcType.setValueType("tpcw.bean.ShoppingCartLine");

		// Key fields for shopping_cart_line.
		Collection<JdbcTypeField> keys = new ArrayList<>();
		keys.add(new JdbcTypeField(Types.INTEGER, "SCL_SC_ID", int.class,
				"sclScId"));
		keys.add(new JdbcTypeField(Types.INTEGER, "SCL_I_ID", int.class,
				"sclIId"));
		jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

		// Value fields for shopping_cart_line.
		Collection<JdbcTypeField> vals = new ArrayList<>();
		vals.add(new JdbcTypeField(Types.INTEGER, "SCL_SC_ID", int.class,
				"sclScId"));
		vals.add(new JdbcTypeField(Types.INTEGER, "SCL_QTY", Integer.class,
				"sclQty"));
		vals.add(new JdbcTypeField(Types.INTEGER, "SCL_I_ID", int.class,
				"sclIId"));
		jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

		return jdbcType;
	}

	/**
	 * Create SQL Query descriptor for shopping_cart_line.
	 *
	 * @return Configured query entity.
	 */
	private static QueryEntity queryEntityShoppingCartLine() {
		QueryEntity qryEntity = new QueryEntity();

		qryEntity.setKeyType("tpcw.bean.ShoppingCartLineKey");
		qryEntity.setValueType("tpcw.bean.ShoppingCartLine");

		// Query fields for shopping_cart_line.
		LinkedHashMap<String, String> fields = new LinkedHashMap<>();

		fields.put("sclScId", "java.lang.Integer");
		fields.put("sclQty", "java.lang.Integer");
		fields.put("sclIId", "java.lang.Integer");

		qryEntity.setFields(fields);

		// Aliases for fields.
		Map<String, String> aliases = new HashMap<>();

		aliases.put("sclScId", "SCL_SC_ID");
		aliases.put("sclQty", "SCL_QTY");
		aliases.put("sclIId", "SCL_I_ID");

		qryEntity.setAliases(aliases);

		// Indexes for shopping_cart_line.
		Collection<QueryIndex> idxs = new ArrayList<>();

		QueryIndex idx = new QueryIndex();

		idx.setName("PRIMARY");

		LinkedHashMap<String, Boolean> idxFlds = new LinkedHashMap<>();

		idxFlds.put("sclScId", true);
		idxFlds.put("sclIId", true);

		idx.setFields(idxFlds);

		idxs.add(idx);

		qryEntity.setIndexes(idxs);

		return qryEntity;
	}

	static {
		dataSource = new DriverManagerDataSource(
				"jdbc:mysql://localhost:3306/tpcw", "root", "123456");
		dataSource.setDriverClassName("com.mysql.jdbc.Driver");
	}

	/**
	 * Configure cache.
	 *
	 * @param cacheName
	 *            Cache name.
	 * @return Cache configuration.
	 */
	public static <K, V> CacheConfiguration<K, V> cache(String cacheName) {

		CacheJdbcPojoStoreFactory<K, V> storeFactory = new CacheJdbcPojoStoreFactory<K, V>();
		storeFactory.setDataSourceFactory(new DataSourceFactory<DataSource>());

		CacheConfiguration<K, V> ccfg = new CacheConfiguration<>(cacheName);

		ccfg.setCacheStoreFactory(storeFactory);
		ccfg.setReadThrough(true);
		ccfg.setWriteThrough(true);

		// Configure JDBC types.
		Collection<JdbcType> jdbcTypes = new ArrayList<>();
		// Configure query entities.
		Collection<QueryEntity> qryEntities = new ArrayList<>();
		switch (cacheName) {
		case "address":
			jdbcTypes.add(jdbcTypeAddress("address"));
			qryEntities.add(queryEntityAddress());
			break;
		case "author":
			jdbcTypes.add(jdbcTypeAuthor("author"));
			qryEntities.add(queryEntityAuthor());
			break;
		case "ccxacts":
			jdbcTypes.add(jdbcTypeCcXacts("ccxacts"));
			qryEntities.add(queryEntityCcXacts());
			break;
		case "country":
			jdbcTypes.add(jdbcTypeCountry("country"));
			qryEntities.add(queryEntityCountry());
			break;
		case "customer":
			jdbcTypes.add(jdbcTypeCustomer("customer"));
			qryEntities.add(queryEntityCustomer());
			break;
		case "item":
			jdbcTypes.add(jdbcTypeItem("item"));
			qryEntities.add(queryEntityItem());
			break;
		case "orderline":
			jdbcTypes.add(jdbcTypeOrderLine("orderline"));
			qryEntities.add(queryEntityOrderLine());
			break;
		case "orders":
			jdbcTypes.add(jdbcTypeOrders("orders"));
			qryEntities.add(queryEntityOrders());
			break;
		case "shoppingCart":
			jdbcTypes.add(jdbcTypeShoppingCart("shoppingCart"));
			qryEntities.add(queryEntityShoppingCart());
			break;
		case "shoppingCartLine":
			jdbcTypes.add(jdbcTypeShoppingCartLine("shoppingCartLine"));
			qryEntities.add(queryEntityShoppingCartLine());
			break;
		}
		storeFactory
				.setTypes(jdbcTypes.toArray(new JdbcType[jdbcTypes.size()]));

		ccfg.setQueryEntities(qryEntities);

		return ccfg;
	}
}
